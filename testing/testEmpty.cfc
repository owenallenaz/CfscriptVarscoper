component {
	/* function init() {
		// stores the navigation data on reinit
		variables.data = getNavData();
		// stores every instance of the navigation objects which are re-used page to page
		variables.navCache = {};
		
		return this;
	}
	
	// widgets and controllers
	remote function widgetPrimary(required struct rc = {}) {
		Application.globalObj.validate(scope = arguments.rc, name = "menuid", type = "integer", default = 0);
		
		local.nav = getMenuObject();
		local.nav.setCurrent(arguments.rc.menuid);
		local.section = local.nav.getSection(1);
		
		local.current = local.nav.getMenu(arguments.rc.menuid);
		
		if (!StructIsEmpty(local.current) && local.current.getMicrosite()) {
			// hide the primary navigation on menu items inside a microsite menu section
			return "";
		}
		
		return Application.templates.fill(this.plugin.templates.primary, local.section);
	}
	
	remote function widgetFooter(required struct rc = {}) {
		return "footer";
	}
	
	// this function is called by the widget and just passes the data on to renderWidgetSide based on request.menuid
	// this way renderWidgetSide() is entirely procedural so that it can be called by AJAX or internally solely on arguments without regard for "state"
	remote function widgetSide(required struct rc = {}) {
		return Application.controller.call({ plugin = "nav", object = "web", action = "renderWidgetSide", menuid = request.menuid });
	}

	remote function renderWidgetSide(required struct rc = {}) {
		Application.globalObj.validate(scope = arguments.rc, name = "menuid", type = "integer", default = 0);
		
		local.nav = getMenuObject();
		local.nav.setCurrent(arguments.rc.menuid);
		local.menu = local.nav.getMenu(arguments.rc.menuid);
		
		if (StructIsEmpty(local.menu)) {
			return "";
		}
		
		while (local.menu.getDepth() gt 1) {
			local.menu = local.menu.getParent();
		}
		
		local.pass = {
			menu = local.menu,
			guid = CreateUUID()
		};
		
		return Application.templates.fill(this.plugin.templates.side, local.pass);
	}
	
	remote function widgetSitemap(required struct rc = {}) {
		local.sections = Application.globalObj.ArraySortBy(getMenuObject().getSectionArray(), "sortorder", "numeric", "asc");
		
		return Application.templates.fill(this.plugin.templates.sitemap, { sections = local.sections }, { sitemap_inner = this.plugin.templates.sitemap_inner });
	}
	
	// handles a traditional request to the menu system via index.cfm
	remote function handleRequest(required struct rc = {}) {
		return processMenuUrl({ requesturl = "/" & (!IsNull(url.rewrite) ? url.rewrite : ""), urlscope = duplicate(url), formscope = duplicate(form), sessionscope = duplicate(session) });
	}
	
	// returns the HTML string generated by a menuURL solely based on the arguments passed in
	remote function processMenuUrl(required struct rc = {}) {
		Application.globalObj.validate(scope = arguments.rc, name = "requesturl", type = "string", default = "/");
		Application.globalObj.validate(scope = arguments.rc, name = "urlscope", type = "struct", default = StructNew());
		Application.globalObj.validate(scope = arguments.rc, name = "formscope", type = "struct", default = StructNew());
		Application.globalObj.validate(scope = arguments.rc, name = "sessionscope", type = "struct", default = StructNew());
		
		local.start = getTickCount();
		
		local.map = cacheGet("menuMap");
		
		if (IsNull(local.map)) {
			local.temp = getMenuObject().getMenuArray();
			local.map = Application.globalObj.createIndexedStruct(local.temp, "href_raw");
			cachePut("menuMap", local.map, 1);
		}
		
		if (StructKeyExists(local.map, arguments.rc.requesturl)) {
			local.menu = local.map[arguments.rc.requesturl][1];
			if (local.menu.getHomepage() is 1 && local.menu.getHref() is not "/") {
				location(url = "/", addtoken = "false");
			}
			
			if (local.menu.getExpired()) {
				// menu is expired, throw a 404
				getPageContext().getResponse().setStatus(404);
			}
			
			// it is not a good practice to set URL variables as it breaks function encapsulation, but in this case we are hamstrung by our environment
			url.menuid = local.menu.getMenuid();
			
			local.tempSession = duplicate(arguments.rc.sessionscope);
			StructDelete(local.tempSession, "cfid");
			StructDelete(local.tempSession, "cftoken");
			StructDelete(local.tempSession, "sessionid");
			StructDelete(local.tempSession, "urltoken");
			local.hash = "#arguments.rc.requesturl#";
			local.hash &= "_#hash(SerializeJSON(Application.globalObj.lcaseSort(arguments.rc.urlscope)))#";
			local.hash &= "_#hash(SerializeJSON(Application.globalObj.lcaseSort(local.tempSession)))#";
			local.hash &= "_#hash(SerializeJSON(Application.globalObj.lcaseSort(arguments.rc.formscope)))#";
			
			local.cached = cacheGet(local.hash);
			if (!IsNull(local.cached)) {
				return local.cached;
			}
			
			// the include is able to access this variable as if it was the Attributes scope normally passed through cfmodule
			local.attributes = {
				menuid = url.menuid
			};
			
			local.temp = Application.globalObj.includeWithVars("/includes/cms/menu/index.cfm", { attributes = local.attributes });
			
			savecontent variable = "local.return" {
				writeOutput(local.temp.html);
				writeOutput("<!-- Rendered on #Now()# in #getTickCount() - local.start#ms -->");
			}
			
			if (StructKeyExists(request, "cacheEnabled") && request.cacheEnabled && local.menu.getCacheTime() > 0) { */
				// cachePut(local.hash, local.return, local.menu.getCacheTime());
				// local.return.yourmom();
				local.return;
			/* }
			
			return local.return;
		} else {
			// menu not found, throw a 404
			getPageContext().getResponse().setStatus(404);
		}
	}
	
	// returns a menu object either by creating a new one or returning it from the cache.
	// this is required to cache your menu object and ensure it generates menu items with the appropriate type
	public function getMenuObject(required struct rc = {}) {
		Application.globalObj.validate(scope = arguments.rc, name = "type", type = "string", default = "menuItem");
		Application.globalObj.validate(scope = arguments.rc, name = "extra", type = "struct", default = {});

		local.hash = hash(SerializeJSON(Application.globalObj.lcaseSort(arguments.rc)));

		if (StructKeyExists(variables.navCache, local.hash)) {
			return variables.navCache[local.hash];
		}

		local.item = CreateObject("data.menu").init(arguments.rc);
		local.item.setData(variables.data);

		variables.navCache[local.hash] = local.item;

		return local.item;
	}

	// private methods
	// returns the navigation data loaded from the database. This data is loaded into each instance of the navigation you create, 
	// so that we only query the database once per reinit.
	private struct function getNavData() {
		local.data = {
			map = {},
			sections = {}
		};

		local.qry = new query(name = "qryMenus", datasource = application.env.dsn, sql = "
			SELECT
				m.[MenuID],
				m.[ParentID],
				m.[TopParent],
				m.[MenuTypeID],
				m.[MenuName],
				m.[FullPath],
				m.[NewWindow],
				m.[JSLink],
				m.[linkurl],
				m.[Depth],
				m.[ShowOnNav],
				m.[mediaid],
				m.[pageid],
				m.[articleid],
				m.[Description],
				m.[link_menuid],
				m.[link_mediaid],
				m.[StartDate],
				m.[EndDate],
				m.cached,
				m.cacheh,
				m.cachem,
				m.caches,
				m.hidesearch,
				p.[homepage],
				COALESCE(m.[secure],0) AS secure,
				c.SectionName,
				c.SectionID,
				c.SortOrder AS sectionSort,
				c.Levels,
				c.hidden,
				c.microsite
			FROM
				[Menus] m
				INNER JOIN [MenuStatus] s ON
					s.[StatusID] = m.[StatusID]
					AND s.[Publish] = 1
				INNER JOIN [MenuSections] c ON
					c.SectionID = m.[SectionID]
					AND (c.SiteID = :SiteID)
				LEFT OUTER JOIN [Pages] p ON p.pageid = m.pageid
			WHERE
				m.[Del] = 0
			ORDER BY
				c.SortOrder,
				c.SectionID,
				m.[TopSort],
				m.[ParentID],
				m.[SortOrder]
		");
		local.qry.addParam(
			name="SiteID",
			value=application.siteid,
			cfsqltype="cf_sql_integer"
		);
		local.qryMenus = Application.globalObj.qryToArray(local.qry.execute().getResult());

		// fold in images data
		local.media = Application.plugins.media.getObject("mediaApi").get({ mediaid = Application.globalObj.arrayValueList(local.qryMenus, "mediaid") }).data.result;
		local.media = Application.globalObj.createIndexedStruct(local.media, "mediaid");

		local.data.map = Application.globalObj.createIndexedStruct(local.qryMenus, "menuid");
		
		// decorates the data properly
		for(local.i in qryMenus) {
			local.i.childrenids = [];
			local.i.allChildrenids = [];
			local.i.media = StructKeyExists(local.media, local.i.mediaid) ? local.media[local.i.mediaid][1] : "";
			
			if (!StructKeyExists(local.data.sections, local.i.sectionid)) {
				local.data.sections[local.i.sectionid] = {
					sectionid = local.i.sectionid,
					hidden = local.i.hidden,
					sectionname = local.i.sectionname,
					sortorder = local.i.sectionSort,
					microsite = local.i.microsite,
					childrenids = []
				};
			}
		}
		
		// folds the data into a hierarchical structure
		for(local.i in qryMenus) {
			local.parentid = local.i.parentid;
			if (local.parentid is not 0) {
				// if the parentid doesn't exist in the map, then just drop this menu item
				if (StructKeyExists(local.data.map, local.parentid)) {
					ArrayAppend(local.data.map[local.parentid][1].childrenids, val(local.i.menuid));
					
					while(local.parentid is not 0) {
						// neccessary in case ancestor does not exist
						if (StructKeyExists(local.data.map, local.parentid)) {
							ArrayAppend(local.data.map[local.parentid][1].allchildrenids, val(local.i.menuid));
							local.parentid = local.data.map[local.parentid][1].parentid;
						}
					}
				} else {
					StructDelete(local.data.map, local.i.menuid);
				}
			} else {
				ArrayAppend(local.data.sections[local.i.sectionid].childrenids, val(local.i.menuid));
			}
		}
		
		return local.data;
	} */
}
